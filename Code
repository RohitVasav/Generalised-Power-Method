from pylab import *
from numpy import *

def genpower(A):
    n=len(A)
    eigval=zeros(n)
    eigvec=zeros((n,n))
    dom=zeros((n,n))
    for i in range(0,n):
        lambda1=0.0
        X= array([random.rand(n)]).T
        c=1
        while(True):
            lambda_ = X.flat[abs(X).argmax()]
            Y = X/lambda_
            X=dot(A,Y)
            if abs(lambda_-lambda1)<10**-5:
                break
            lambda1=lambda_
            c=c+1
        eigval[i]=lambda_
        Y=Y/norm(Y)
        dom[:,i]=Y[:,0]
        G=dom[:,i]
        for j in range(0,i):
            G=(eigval[i]-eigval[i-j-1])*G+eigval[i-j-1]*dot(dom[:,i-j-1].T,G)*dom[:,i-j-1]
            G=G/norm(G)
        eigvec[:,i]=G
        A = A - lambda_*dot(Y,Y.T)
    idx = eigval.argsort()
    eigval = eigval[idx]
    eigvec = eigvec[:,idx]
    return array(eigval),array(eigvec)
    
N=100
xi,xf=-6,6
X=linspace(xi,xf,N)
delta=(xf-xi)/N

def U(y):
    return y**2
    
T = diag(-2*X**0,0) + diag(X[1:N]**0,-1) + diag(X[1:N]**0,1)    # double derivative tri-diagonal matrix
P = diag(U(X))                      # potential diagonal matrix
H = T/(-delta**2) + P               # Hermitian Matrix

H_eigenvalues, H_eigenvectors = genpower(H)
H_eigenvectors /= -sqrt(N*delta)

mod=[H_eigenvectors[:,i] @ H_eigenvectors[:,i].conj().T for i in range(0,N)]

n=5

plot(X,10*H_eigenvectors[:,0:n]+H_eigenvalues[0:n],color="green")
plot(X,U(X),label="Potential")
hlines(H_eigenvalues[0:n],xmin=min(X),xmax=max(X),color="red")
ylim(0,10)
legend()
